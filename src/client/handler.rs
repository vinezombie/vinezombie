mod delay;
mod run;

pub use delay::*;
pub use run::*;

use super::Queue;
use crate::ircmsg::ServerMsg;

/// The return type of the `handle` methods on types in this module.
pub type HandlerResult<T, W, E> = Result<HandlerOk<T, W>, E>;

/// All the possible forms of success for a single handler step.
#[derive(Clone, PartialEq, Eq, Hash, Debug, Default)]
pub enum HandlerOk<T, W> {
    /// The provided message isn't relevant to this handler and has been ignored.
    #[default]
    Ignored,
    /// More messages are required.
    NeedMore,
    /// More messages are required.
    /// Additionally, a handler step has errored but recovered successfully.
    Warning(W),
    /// The handler has yielded a value.
    Value(T),
}

/// Closure-like types that can be run off of message streams.
///
/// This trait has a blanket implementation for [`FnMut`]s that
/// match the signature of `handle`.
pub trait Handler {
    /// The type of value this handler yields on completion.
    type Value;
    /// The type of this handler's warnings.
    type Warning: std::fmt::Display;
    /// The type of this handler's errors.
    type Error: From<std::io::Error>;
    /// Handles one message.
    fn handle(
        &mut self,
        msg: &ServerMsg<'_>,
        queue: &mut Queue<'static>,
    ) -> HandlerResult<Self::Value, Self::Warning, Self::Error>;
}

/// Handlers that can generate asynchronous tasks from message streams.
///
/// Unlike [`Handler`], `HandlerAsync` has two methods:
/// one for handling messages, and one handling the completion of a task.
/// Both methods are provided a mutable reference to a collection `T`
/// to which tasks can be added, which will then be driven outside the handler.
pub trait HandlerAsync<T> {
    /// The value returned by tasks generated by this handler.
    type TaskValue;
    /// The type of value this handler yields on completion.
    type Value;
    /// The type of this handler's warnings.
    type Warning: std::fmt::Display;
    /// The type of this handler's errors.
    type Error: From<std::io::Error>;
    /// Handles one message.
    fn handle_msg(
        &mut self,
        msg: &ServerMsg<'_>,
        tasks: &mut T,
        queue: &mut Queue<'static>,
    ) -> HandlerResult<Self::Value, Self::Warning, Self::Error>;
    /// Handles a future yielding a value.
    fn handle_value(
        &mut self,
        value: Self::TaskValue,
        tasks: &mut T,
        queue: &mut Queue<'static>,
    ) -> HandlerResult<Self::Value, Self::Warning, Self::Error>;
}

impl<
        T,
        W: std::fmt::Display,
        E: From<std::io::Error>,
        F: FnMut(&ServerMsg<'_>, &mut Queue<'static>) -> HandlerResult<T, W, E>,
    > Handler for F
{
    type Value = T;
    type Warning = W;
    type Error = E;
    fn handle(
        &mut self,
        msg: &ServerMsg<'_>,
        queue: &mut Queue<'static>,
    ) -> HandlerResult<Self::Value, Self::Warning, Self::Error> {
        self(msg, queue)
    }
}

impl<T, H: Handler> HandlerAsync<T> for H {
    type TaskValue = std::convert::Infallible;
    type Value = H::Value;
    type Warning = H::Warning;
    type Error = H::Error;

    fn handle_msg(
        &mut self,
        msg: &ServerMsg<'_>,
        _: &mut T,
        queue: &mut Queue<'static>,
    ) -> HandlerResult<Self::Value, Self::Warning, Self::Error> {
        self.handle(msg, queue)
    }

    fn handle_value(
        &mut self,
        _: Self::TaskValue,
        _: &mut T,
        _: &mut Queue<'static>,
    ) -> HandlerResult<Self::Value, Self::Warning, Self::Error> {
        unimplemented!()
    }
}
